export interface DeclarationBase {
    jsDocComment?: string;
    comment?: string;
    flags?: DeclarationFlags;
}
export interface EnumMemberDeclaration extends DeclarationBase {
    kind: "enum-value";
    name: string;
    value?: string | number;
}
export interface EnumDeclaration extends DeclarationBase {
    kind: "enum";
    name: string;
    members: EnumMemberDeclaration[];
    constant: boolean;
}
export interface PropertyDeclaration extends DeclarationBase {
    kind: "property";
    name: string;
    type: Type;
}
export interface Parameter {
    kind: "parameter";
    name: string;
    type: Type;
    flags?: ParameterFlags;
}
export interface TypeParameter {
    kind: "type-parameter";
    name: string;
    baseType?: ObjectTypeReference | TypeParameter;
    defaultType?: Type;
}
export interface IndexSignature extends DeclarationBase {
    kind: "index-signature";
    name: string;
    indexType: ("string" | "number");
    valueType: Type;
}
export interface CallSignature extends DeclarationBase {
    kind: "call-signature";
    parameters: Parameter[];
    returnType: Type;
    typeParameters: TypeParameter[];
}
export interface MethodDeclaration extends DeclarationBase {
    kind: "method";
    name: string;
    parameters: Parameter[];
    returnType: Type;
    typeParameters: TypeParameter[];
}
export interface FunctionDeclaration extends DeclarationBase {
    kind: "function";
    name: string;
    parameters: Parameter[];
    returnType: Type;
    typeParameters: TypeParameter[];
}
export interface ConstructorDeclaration extends DeclarationBase {
    kind: "constructor";
    parameters: Parameter[];
}
export interface ClassDeclaration extends DeclarationBase {
    kind: "class";
    name: string;
    members: ClassMember[];
    implements: InterfaceDeclaration[];
    typeParameters: TypeParameter[];
    baseType?: ObjectTypeReference;
}
export interface InterfaceDeclaration extends DeclarationBase {
    kind: "interface";
    name: string;
    members: ObjectTypeMember[];
    baseTypes?: ObjectTypeReference[];
}
export interface ImportAllDeclaration extends DeclarationBase {
    kind: "importAll";
    name: string;
    from: string;
}
export interface ImportNamedDeclaration extends DeclarationBase {
    kind: "importNamed";
    name: string;
    as?: string;
    from: string;
}
export interface ImportDefaultDeclaration extends DeclarationBase {
    kind: "importDefault";
    name: string;
    from: string;
}
export interface ImportEqualsDeclaration extends DeclarationBase {
    kind: "import=";
    name: string;
    from: string;
}
export interface ImportDeclaration extends DeclarationBase {
    kind: "import";
    from: string;
}
export interface NamespaceDeclaration extends DeclarationBase {
    kind: "namespace";
    name: string;
    members: NamespaceMember[];
}
export interface ConstDeclaration extends DeclarationBase {
    kind: "const";
    name: string;
    type: Type;
}
export interface VariableDeclaration extends DeclarationBase {
    kind: "var";
    name: string;
    type: Type;
}
export interface ExportEqualsDeclaration extends DeclarationBase {
    kind: "export=";
    target: string;
}
export interface ExportDefaultDeclaration extends DeclarationBase {
    kind: "exportDefault";
    name: string;
}
export interface ExportNameDeclaration extends DeclarationBase {
    kind: "exportName";
    name: string;
    as?: string;
}
export interface ModuleDeclaration extends DeclarationBase {
    kind: "module";
    name: string;
    members: ModuleMember[];
}
export interface ObjectType {
    kind: "object";
    members: ObjectTypeMember[];
}
export interface UnionType {
    kind: "union";
    members: Type[];
}
export interface IntersectionType {
    kind: "intersection";
    members: Type[];
}
export interface FunctionType {
    kind: "function-type";
    parameters: Parameter[];
    returnType: Type;
}
export interface TypeAliasDeclaration extends DeclarationBase {
    kind: "alias";
    name: string;
    type: Type;
    typeParameters: TypeParameter[];
}
export interface ArrayTypeReference {
    kind: "array";
    type: Type;
}
export interface NamedTypeReference {
    kind: "name";
    name: string;
}
export interface TypeofReference {
    kind: "typeof";
    type: NamedTypeReference;
}
export interface StringLiteral {
    kind: "string-literal";
    value: string;
}
export interface NumberLiteral {
    kind: "number-literal";
    value: number;
}
export interface TripleSlashReferencePathDirective {
    kind: "triple-slash-reference-path";
    path: string;
}
export interface TripleSlashReferenceTypesDirective {
    kind: "triple-slash-reference-types";
    types: string;
}
export interface TripleSlashReferenceNoDefaultLibDirective {
    kind: "triple-slash-reference-no-default-lib";
    value: boolean;
}
export interface TripleSlashAmdModuleDirective {
    kind: "triple-slash-amd-module";
    name?: string;
}
export declare type PrimitiveType = "string" | "number" | "boolean" | "any" | "void" | "object" | "null" | "undefined" | "true" | "false" | StringLiteral | NumberLiteral;
export declare type ThisType = "this";
export declare type TripleSlashDirective = TripleSlashReferencePathDirective | TripleSlashReferenceTypesDirective | TripleSlashReferenceNoDefaultLibDirective | TripleSlashAmdModuleDirective;
export declare type TypeReference = TopLevelDeclaration | NamedTypeReference | ArrayTypeReference | PrimitiveType;
export declare type ObjectTypeReference = ClassDeclaration | InterfaceDeclaration;
export declare type ObjectTypeMember = PropertyDeclaration | MethodDeclaration | IndexSignature | CallSignature;
export declare type ClassMember = PropertyDeclaration | MethodDeclaration | IndexSignature | ConstructorDeclaration;
export declare type Type = TypeReference | UnionType | IntersectionType | PrimitiveType | ObjectType | TypeofReference | FunctionType | TypeParameter | ThisType;
export declare type Import = ImportAllDeclaration | ImportDefaultDeclaration | ImportNamedDeclaration | ImportEqualsDeclaration | ImportDeclaration;
export declare type NamespaceMember = InterfaceDeclaration | TypeAliasDeclaration | ClassDeclaration | NamespaceDeclaration | ConstDeclaration | VariableDeclaration | FunctionDeclaration;
export declare type ModuleMember = InterfaceDeclaration | TypeAliasDeclaration | ClassDeclaration | NamespaceDeclaration | ConstDeclaration | VariableDeclaration | FunctionDeclaration | Import | ExportEqualsDeclaration | ExportDefaultDeclaration;
export declare type TopLevelDeclaration = NamespaceMember | ExportEqualsDeclaration | ExportDefaultDeclaration | ExportNameDeclaration | ModuleDeclaration | EnumDeclaration | Import;
export declare enum DeclarationFlags {
    None = 0,
    Private = 1,
    Protected = 2,
    Static = 4,
    Optional = 8,
    Export = 16,
    Abstract = 32,
    ExportDefault = 64,
    ReadOnly = 128,
}
export declare enum ParameterFlags {
    None = 0,
    Optional = 1,
    Rest = 2,
}
export declare const config: {
    wrapJsDocComments: boolean;
    outputEol: string;
};
export declare const create: {
    interface(name: string, flags?: DeclarationFlags): InterfaceDeclaration;
    class(name: string, flags?: DeclarationFlags): ClassDeclaration;
    typeParameter(name: string, baseType?: InterfaceDeclaration | ClassDeclaration | TypeParameter | undefined): TypeParameter;
    enum(name: string, constant?: boolean, flags?: DeclarationFlags): EnumDeclaration;
    enumValue(name: string, value?: string | number | undefined): EnumMemberDeclaration;
    property(name: string, type: Type, flags?: DeclarationFlags): PropertyDeclaration;
    method(name: string, parameters: Parameter[], returnType: Type, flags?: DeclarationFlags): MethodDeclaration;
    callSignature(parameters: Parameter[], returnType: Type): CallSignature;
    function(name: string, parameters: Parameter[], returnType: Type, flags?: DeclarationFlags): FunctionDeclaration;
    functionType(parameters: Parameter[], returnType: Type): FunctionType;
    parameter(name: string, type: Type, flags?: ParameterFlags): Parameter;
    constructor(parameters: Parameter[], flags?: DeclarationFlags): ConstructorDeclaration;
    const(name: string, type: Type, flags?: DeclarationFlags): ConstDeclaration;
    variable(name: string, type: Type): VariableDeclaration;
    alias(name: string, type: Type, flags?: DeclarationFlags): TypeAliasDeclaration;
    namespace(name: string): NamespaceDeclaration;
    objectType(members: ObjectTypeMember[]): ObjectType;
    indexSignature(name: string, indexType: "string" | "number", valueType: Type): IndexSignature;
    array(type: Type): ArrayTypeReference;
    namedTypeReference(name: string): NamedTypeReference;
    exportEquals(target: string): ExportEqualsDeclaration;
    exportDefault(name: string): ExportDefaultDeclaration;
    exportName(name: string, as?: string | undefined): ExportNameDeclaration;
    module(name: string): ModuleDeclaration;
    importAll(name: string, from: string): ImportAllDeclaration;
    importDefault(name: string, from: string): ImportDefaultDeclaration;
    importNamed(name: string, as: string, from?: string | undefined): ImportNamedDeclaration;
    importEquals(name: string, from: string): ImportEqualsDeclaration;
    import(from: string): ImportDeclaration;
    union(members: Type[]): UnionType;
    intersection(members: Type[]): IntersectionType;
    typeof(type: NamedTypeReference): TypeofReference;
    tripleSlashReferencePathDirective(path: string): TripleSlashReferencePathDirective;
    tripleSlashReferenceTypesDirective(types: string): TripleSlashReferenceTypesDirective;
    tripleSlashReferenceNoDefaultLibDirective(value?: boolean): TripleSlashReferenceNoDefaultLibDirective;
    tripleSlashAmdModuleDirective(name?: string | undefined): TripleSlashAmdModuleDirective;
};
export declare const type: {
    array(type: Type): ArrayTypeReference;
    stringLiteral(string: string): PrimitiveType;
    numberLiteral(number: number): PrimitiveType;
    string: PrimitiveType;
    number: PrimitiveType;
    boolean: PrimitiveType;
    any: PrimitiveType;
    void: PrimitiveType;
    object: PrimitiveType;
    null: PrimitiveType;
    undefined: PrimitiveType;
    true: PrimitiveType;
    false: PrimitiveType;
    this: "this";
};
export declare const reservedWords: string[];
/** IdentifierName can be written as unquoted property names, but may be reserved words. */
export declare function isIdentifierName(s: string): boolean;
/** Identifiers are e.g. legal variable names. They may not be reserved words */
export declare function isIdentifier(s: string): boolean;
export declare enum ContextFlags {
    None = 0,
    Module = 1,
    InAmbientNamespace = 2,
}
export declare function never(x: never, err: string): never;
export interface EmitOptions {
    rootFlags?: ContextFlags;
    tripleSlashDirectives?: TripleSlashDirective[];
    singleLineJsDocComments?: boolean;
}
export declare function emit(rootDecl: TopLevelDeclaration, {rootFlags, tripleSlashDirectives, singleLineJsDocComments}?: EmitOptions): string;
